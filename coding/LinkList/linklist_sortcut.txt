   string longestPalindrome(string s) {

        int i,len1,len2,len,prevlen=0;
        int start=0,end=0;
        int slen = s.size();
        
        if(s.empty() || s.length() < 1)
            return "";
            
        for(i=0;i<slen-1;i++){
            len1 = expandfrommiddle(s,i,i); 
            len2 = expandfrommiddle(s,i,i+1);
            
            len = max(len1,len2);
            
            if(len > (end-start) && len != prevlen ){
                //std::cout << "______ 1 ______";
                start = i - (len-1)/2;
                end = i + len/2;
                
                std::cout << "start=" << start << "\tend=" << end << "\ti="<<i << "\tlen="<<len;
                std::cout << "\n";
            }
            prevlen  = len;
        }
        
        return s.substr(start,len); // substr([position], [length]) --->>> to calculate the length from start and end position of substring --->>> end - start + 1 ( As array index start from 0 but length of substring will be actual length which start from 1)
    }
    
    int expandfrommiddle(string s,int left, int right){
        if(left>right)
            return 0;
        
        
        while(left >=0 && right<s.length() && s[left] == s[right] ){
            left--;
            right++;
        }
        return right-left-1; // subtracting -1 as during finding substring we moved one step ahead.
    }
#######################

intersectionpoint:

while(temp1 != temp2){

	if(temp1 == NULL)
		temp1 = headB;
	if(temp2 == NULL)
		temp2 = headA;
	
	temp1 = temp1->next;
	temp2 = temp2->next;
}
return temp1;


############################
detect loop:

while( fast!=slow ){
	fast = fast->next->next;
	slow = slow->next;
}

fast = head;

while(fast!=slow){
	fast = fast->next;
	slow = slow->next;
}

return fast;

####################################
for forward direction linking: used in linklist merging

struct node dummy;
struct node *tail=dummy->next;
tail=NULL;
move(&tail->next, src);
tail = tail->next;

for backward direction linking: used in reverse the list
struct *tail = NULL;
move(&tail, &src);


void *move(struct list **dest, struct **src){

	struct list* newnode = *src;

	*src = newnode->next;

	newnode->next = *dest;

	*dest = newnode;
}

#########################################################
node insert from front using double pointer

void insert_node(struct node** head, int val){
    struct node* temp = (struct node*)malloc(sizeof(struct node));
    temp->val = val;
    temp->next = *head;
    *head = temp;
}
